from sklearn import svm
from sklearn import datasets
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.preprocessing import StandardScaler, PolynomialFeatures
from sklearn.pipeline import Pipeline
from mpl_toolkits.mplot3d import Axes3D

scaler = StandardScaler()

np.random.seed(42)

df = pd.read_csv('data.csv')

df['Bankrupt?'] = pd.Categorical(df['Bankrupt?'])

dependentVariable = ['Bankrupt?']

featureGroupA = [
    'Tax rate (A)',
    'Net Value Per Share (B)',
    'Net Value Per Share (A)',
    'Net Value Per Share (C)',
    'Persistent EPS in the Last Four Seasons',
    'Operating Profit Per Share (Yuan ¥)',
    'Per Share Net profit before tax (Yuan ¥)',
    'Debt ratio %',
    'Operating profit/Paid-in capital',
    'Net profit before tax/Paid-in capital',
    'Quick Assets/Total Assets',
    'Cash/Total Assets',
    'Current Liability to Assets',
    'Total expense/Assets',
    'Equity to Long-term Liability',
    'Liability-Assets Flag',
    'Equity to Liability'
    ]

df.columns = df.columns.str.strip().str.lower()
independentVariablesA = [col.lower() for col in featureGroupA]
df['independentVariableA'] = df[independentVariablesA].mean(axis=1)

featureGroupB = [
    'Operating Gross Margin',
    'Realized Sales Gross Margin',
    'Net worth/Assets',
    'Working Capital to Total Assets',
    'Working Capital/Equity',
    'Retained Earnings to Total Assets',
    'Current Liability to Current Assets',
    'Net Income to Total Assets',
    'Gross Profit to Sales',
    'Net Income to Stockholder\'s Equity'
]

independentVariablesB = [col.lower() for col in featureGroupB]
df['independentVariableB'] = df[independentVariablesB].mean(axis=1)

featureGroupC = [
    'CFO to Assets',
    'Borrowing dependency',
    'Operating profit per person',
    'ROA(A) before interest and % after tax',
    'ROA(B) before interest and depreciation after tax',
    'ROA(C) before interest and depreciation before interest',
    'Current Liabilities/Equity',
    'Current Liability to Equity',
    'Liability to Equity'
]

independentVariablesC = [col.lower() for col in featureGroupC]
df['independentVariableC'] = df[independentVariablesC].mean(axis=1)

dependentVariable = [col.lower() for col in dependentVariable]

X = df[['independentVariableA', 'independentVariableB', 'independentVariableC']]

Y = df[dependentVariable]

Y = Y.values.ravel()

#Data is split into 80% Training - 20% Test
trainX, testX, trainY, testY = train_test_split(X, Y, test_size=0.2, random_state=42)

trainX_scaled = StandardScaler().fit_transform(trainX)

testX_scaled = StandardScaler().fit_transform(testX)

polynomial_svm_clf = Pipeline([
    ("poly_features", PolynomialFeatures(degree=3)),
    ("scaler", StandardScaler()),
    ("svm_clf", svm.LinearSVC(C=100000, loss="squared_hinge"))
])

polynomial_svm_clf.fit(trainX, trainY)

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')

levels = [0]

def plot_predictions(clf, axes):
    x0s = np.linspace(axes[0], axes[1], 100)
    x1s = np.linspace(axes[2], axes[3], 100)
    x2s = np.linspace(axes[4], axes[5], 100)
    x0, x1 = np.meshgrid(x0s, x1s)
    x2_fixed = np.mean(x2s)
    x2 = np.full_like(x0, x2_fixed)
    X = np.c_[x0.ravel(), x1.ravel(), x2.ravel()]
    y_pred = clf.predict(X).reshape(x0.shape)
    y_decision = clf.decision_function(X).reshape(x0.shape)
    ax.plot_surface(x0, x1, y_decision, cmap="binary")
    
def plot_dataset(X, y, axes):
    ax.scatter(X.iloc[:, 0][y==0], X.iloc[:, 1][y==0], X.iloc[:, 2][y==0], "bs")
    ax.scatter(X.iloc[:, 0][y==1], X.iloc[:, 1][y==1], X.iloc[:, 2][y==1], "g^")
    ax.set_xlabel('Feature 1')
    ax.set_ylabel('Feature 2')
    ax.set_zlabel('Feature 3')

plot_predictions(polynomial_svm_clf, [.1, .3, .45, .8, .3, .5])
plot_dataset(trainX, trainY, [.1, .3, .45, .8, .3, .5])

plt.show()

print('Evaluation: ')
trainPredictions = polynomial_svm_clf.predict(trainX)
testPredictions = polynomial_svm_clf.predict(testX)

trainAccuracy = accuracy_score(trainY, trainPredictions)
testAccuracy = accuracy_score(testY, testPredictions)

print('The training accuracy of this model was ', trainAccuracy * 100, '%')
print('The testing accuracy of this model was ', testAccuracy * 100, '%')

if (testAccuracy < (trainAccuracy - 10)):
    print('This model is overfitting')
else:
    print('This model performs consistently')
print('Made it through')
